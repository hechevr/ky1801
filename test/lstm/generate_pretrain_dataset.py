import os
import sys
import csv
import random

from utils import CHORD

major = ['C', 'C#', 'Cb', 'D', 'D#', 'Db', 'E', 'E#', 'Eb', 'F', 'F#', 'Fb', 'G', 'G#', 'Gb', 'A', 'A#', 'Ab', 'B', 'B#', 'Bb', 'c', 'c#', 'cb', 'd', 'd#', 'db', 'e', 'e#', 'eb', 'f', 'f#', 'fb', 'g', 'g#','gb','a','a#','ab','b', 'b#', 'bb']
chords = ['I', 'I+', 'II', 'II+', 'III', 'III+', 'IV', 'IV+', 'V', 'V+', 'VI', 'VI+', 'VII', 'VII+']

def freq2prob(s):
    if (s == 'H'):
        return 0.8
    else:
        return 0.2

def read_trans_prob(filename):
    prob = []
    with open(filename, "r") as fo:
        reader = csv.reader(fo)
        for idx, row in enumerate(reader):
            if (idx > 0):
                prob.append(row[1:])
    print(prob)
    return prob

def load_table():
    table = []
    with open("EmissionProbability.csv") as csvfile:
        reader = csv.reader(csvfile)
        for row in reader:
            if (row[0] in major):
                title = row[0]
            else:
                row[0] = title + " " + row[0]
                table.append(row)
    return table

def lookup(s, table):
    data = []
    for t in table:
        print(s, t)
        if s in t:
            data.append(t)
    return data

def str2vec(s):
    # parse string into vector
    # s = [chord keys]
    if (len(s) < 1):
        return []
    vec = [0.0] * 12
    vec_str = s.split()
    print(vec_str)
    if ('C' in vec_str):
        vec[0] = 1
    if ('D' in vec_str):
        vec[2] = 1
    if ('E' in vec_str):
        vec[4] = 1
    if ('F' in vec_str):
        vec[5] = 1
    if ('G' in vec_str):
        vec[7] = 1
    if ('A' in vec_str):
        vec[9] = 1
    if ('B' in vec_str):
        vec[11] = 1

    # normalization
    s = sum(vec)
    vec = [round(v/s, 2) for v in vec]
    return vec

def generate_dataset(num=200):
    # generate transition selection table
    transSelectTable = []
    for p in trans_p:
        chordList = []
        # add possible options according to frequency
        for idx, item in enumerate(p):
            if (item == 'H'):
                # add 3 trans chord
                chordList.append(chords[idx*2])
                chordList.append(chords[idx*2+1])
                chordList.append(chords[idx * 2])
                chordList.append(chords[idx * 2 + 1])
                chordList.append(chords[idx * 2])
                chordList.append(chords[idx * 2 + 1])
            elif (item == 'L'):
                # add 1 trans chord
                chordList.append(chords[idx*2])
                chordList.append(chords[idx*2+1])
        transSelectTable.append(chordList)

    for idx, p in enumerate(transSelectTable):
        print(idx, p)

    data = []
    count = 0
    while (True):
        # random choose chord
        chordA_idx = int(random.random()*len(chords))
        chordA = chords[chordA_idx]
        # random choose next chord
        print(chordA_idx)
        print(chordA)
        chordB_idx = int(random.random()*len(transSelectTable[int(chordA_idx/2)]))
        chordB = transSelectTable[int(chordA_idx/2)][chordB_idx]

        # random choose one notes for chordA and chordB
        noteList = lookup("C " + chordA, table)
        if (len(noteList) <= 0):
            continue
        noteList = noteList[0]
        noteA_idx = int(random.random() * len(noteList[1:]))
        noteA = str2vec(noteList[1+noteA_idx])

        noteList = lookup("C " + chordB, table)
        if (len(noteList) <= 0):
            continue
        noteList = noteList[0]
        noteB_idx = int(random.random()*len(noteList[1:]))
        noteB = str2vec(noteList[1+noteB_idx])

        # print(chordA)
        # print(noteA)
        # print(chordB)
        # print(noteB)
        line = []
        line.append(count)
        line.append([noteA, noteB])
        line.append([chordA, chordB])
        data.append(line)
        count += 1
        if (count >= num):
            break
    with open('pretrain_data.csv', "w") as fo:
        fo.write('.pretrain data generated by musical knowledge\n')
        for d in data:
            fo.write(str(d[0]) + ';')
            fo.write("[")
            fo.write(str(d[1][0]) + ",")
            fo.write(str(d[1][1]) + "];")
            fo.write(str(d[2][0]) + ";")
            fo.write(str(d[2][1]) + "\n")


if __name__ == "__main__":
    table = load_table()

    trans_p = read_trans_prob("TransitionProbability.csv")
    print(trans_p)

    generate_dataset()
